% This file is automatically generated from coq_elpi_builtin.ml
% See also coq-HOAS.elpi


% -- Printing (debugging) ---------------------------------------------

% [coq.say ...] Prints an info message
external type coq.say variadic any prop.

% [coq.warn ...] Prints a warning message
external type coq.warn variadic any prop.

% [coq.error ...] Prints and *aborts* the program (it's a fatal error)
external type coq.error variadic any prop.

% -- Nametab ----------------------------------------------------------

% [coq.locate Name TermFound] See the Locate vernacular. TermFound is indc,
% indt or const
external pred coq.locate i:string, o:term.

% A few more external data types (names of modules and module types)

% [coq.locate-module ModName ModPath] locates a module. *E*
external pred coq.locate-module i:@id, o:@modpath.

% [coq.locate-module-type ModName ModPath] locates a module. *E*
external pred coq.locate-module-type i:@id, o:@modtypath.

% -- Environment: read ------------------------------------------------

% [coq.env.typeof-gr GR Ty] reads the type Ty of a (const GR, indt GR, indc
% GR)
external pred coq.env.typeof-gr i:@gref, o:term.

% While constants, inductive type and inductive constructors do share the
% same data type for their names, namely @gref, the predicates named
% coq.env-{const,indt,indc} can only be used for objects of kind
% {const,indt,indc} respectively.

external pred coq.env.indt % reads the inductive type declaration for the environment
  i:@gref, % reference to the inductive type
  o:bool,  % tt if the type is inductive (ff for co-inductive)
  o:int,   % number of parameters
  o:int,   % number of parameters that are uniform (<= parameters)
  o:term,  % type of the inductive type constructor including parameters
  o:list term,
   % list of constructors like [ (indc "O"); (indc "S") ]
  o:list term.
   % list of the types of the constructors (type of KNames)
  
% [coq.env.indc GR ParamNo UnifParamNo Kno Ty] reads the type Ty of an
% inductive constructor GR, as well as the number of parameters ParamNo and
% uniform parameters UnifParamNo and the number of the constructor Kno (0
% based)
external pred coq.env.indc i:@gref, o:int, o:int, o:int, o:term.

% [coq.env.const-opaque? GR] checks if GR is an opaque constant
external pred coq.env.const-opaque? i:@gref.

% [coq.env.const GR Bo Ty] reads the type Ty and the body Bo of constant GR.
% Opaque constants have Bo = hole.
external pred coq.env.const i:@gref, o:term, o:term.

% [coq.env.const-body GR Bo] reads the body of a constant, even if it is
% opaque. If such body is hole, then the constant is a true axiom
external pred coq.env.const-body i:@gref, o:term.

% [coq.env.module MP Contents] lists the contents of a module (recurses on
% submodules) *E*
external pred coq.env.module i:@modpath, o:list term.

% [coq.env.module-type MTP Entries] lists the items made visible by module
% type (does not recurse on submodules) *E*
external pred coq.env.module-type i:@modtypath, o:list @id.

% -- Environment: write -----------------------------------------------

% Note: universe constraints are taken from ELPI's constraints store. Use
% coq.univ-* in order to add constraints (or any higher level facility as
% coq.elaborate or of from engine/elaborator.elpi)

% [coq.env.add-const Name Bo Ty Opaque T] declare a new constant: T gets
% (const GR) for a new GR derived from Name and the current module; Type can
% be left unspecified and in that case the inferred one is taken (as in
% writing Definition x := t); Body can be unspecified and in that case an
% axiom is added
external pred coq.env.add-const i:@id, i:term, i:term, i:@opaque?, o:term.

% [coq.env.add-indt Decl I] Declares an inductive type
external pred coq.env.add-indt i:indt-decl, o:term.

% Interactive module construction

% [coq.env.begin-module Name ModTyPath] Starts a module, the modtype can be
% unspecified *E*
external pred coq.env.begin-module i:@id, i:@modtypath.

% [coq.env.end-module ModPath] end the current module that becomes known as
% ModPath *E*
external pred coq.env.end-module o:@modpath.

% [coq.env.begin-module-type Name] Starts a module type *E*
external pred coq.env.begin-module-type i:@id.

% [coq.env.end-module-type ModTyPath] end the current module type that
% becomes known as ModPath *E*
external pred coq.env.end-module-type o:@modtypath.

% [coq.env.include-module ModPath] is like the vernacular Include *E*
external pred coq.env.include-module i:@modpath.

% [coq.env.include-module-type ModTyPath] is like the vernacular Include *E*
external pred coq.env.include-module-type i:@modtypath.

% -- Universes --------------------------------------------------------

% [coq.univ.print-constraints] prints the set of universe constraints
external pred coq.univ.print-constraints .

% [coq.univ.leq U1 U2] constrains U1 <= U2
external pred coq.univ.leq o:@univ, o:@univ.

% [coq.univ.eq U1 U2] constrains U1 = U2
external pred coq.univ.eq o:@univ, o:@univ.

% [coq.univ.new Names U] fresh universe *E*
external pred coq.univ.new i:list @id, o:@univ.

% [coq.univ.sup U1 U2] constrains U2 = U1 + 1
external pred coq.univ.sup o:@univ, o:@univ.

% [coq.univ.max U1 U2 U3] constrains U3 = max U1 U2
external pred coq.univ.max o:@univ, o:@univ, o:@univ.

% Very low level, don't use

% [coq.univ.algebraic-max U1 U2 U3] constrains U3 = Max(U1,U2) *E*
external pred coq.univ.algebraic-max o:@univ, o:@univ, o:@univ.

% [coq.univ.algebraic-sup U1 U2] constrains U2 = Sup(U1) *E*
external pred coq.univ.algebraic-sup o:@univ, o:@univ.

% -- Databases (TC, CS, Coercions) ------------------------------------

% [coq.CS.declare-instance GR] declares GR as a canonical structure instance
external pred coq.CS.declare-instance i:@gref.

% [coq.CS.db Db] reads all instances
external pred coq.CS.db o:list cs-instance.

% [coq.TC.declare-instance GR Priority Global] declare GR as a Global type
% class instance with Priority
external pred coq.TC.declare-instance i:@gref, i:int, i:@global?.

% [coq.TC.db Db] reads all instances
external pred coq.TC.db o:list tc-instance.

% [coq.TC.db-for GR Db] reads all instances of the given class GR
external pred coq.TC.db-for i:@gref, o:list tc-instance.

% [coq.TC.class? GR] checks if GR is a class
external pred coq.TC.class? i:@gref.

% [coq.coercion.declare GR From To Global] declares GR as a coercion From
% >-> To. To can also be {{ _ -> _ }} or {{ Type }} for Funclass or
% Sortclass
external pred coq.coercion.declare i:@gref, i:term, i:term, i:@global?.

% -- Coq's pretyper ---------------------------------------------------

% [coq.typecheck T Ty] typchecks a closed term (no holes, no context). This
% limitation shall be lifted in the future. Inferred universe constraints
% are put in the constraint store
external pred coq.typecheck i:term, o:term.

% [coq.elaborate T E ETy] elabotares terms that can contain "hole".  It is
% able to work in a proof and hypothetical context, as long as all bound
% variables are accompanied by a decl or def hypothesis. Limitation: the
% resulting term has to be evar free (no unresolved holes), shall be lifted
% in the future
external pred coq.elaborate i:term, o:term, o:term.

% -- Datatypes conversions --------------------------------------------

% [coq.name-suffix Name Suffix NameSuffix] suffixes a Name with a string or
% an int or another name
external pred coq.name-suffix i:@name, i:any, o:@name.

% [coq.string->name Hint Name] creates a name hint
external pred coq.string->name i:string, o:@name.

% [coq.gr->id GR Id] extracts the label (last component of a full kernel
% name). Accepts also as @id in input, in this case it is the identity
external pred coq.gr->id i:any, o:@id.

% [coq.gr->string GR FullPath] extract the full kernel name. GR can be a
% @gref or @id
external pred coq.gr->string i:any, o:string.

% [coq.term->string T S] prints a term T to a string S using Coq's pretty
% printer
external pred coq.term->string i:term, o:string.

% -- Access to Elpi's data --------------------------------------------

% [coq.elpi.accumulate DbName Clause] Declare that, once the program is
% over, the given clause has to be added to the given db (see Elpi Db)
external pred coq.elpi.accumulate i:@id, i:clause.

%  == I/O builtins =====================================

%  -- I/O --

macro @in_stream :- ctype "in_stream".

macro @out_stream :- ctype "out_stream".

type std_in @in_stream.

type std_out @out_stream.

type std_err @out_stream.

% [open_in FileName InStream] opens FileName for input
external pred open_in i:string, o:@in_stream.

% [open_out FileName OutStream] opens FileName for output
external pred open_out i:string, o:@out_stream.

% [open_append FileName OutStream] opens FileName for output in append mode
external pred open_append i:string, o:@out_stream.

% [close_in InStream] closes input stream InStream
external pred close_in i:@in_stream.

% [close_out OutStream] closes output stream OutStream
external pred close_out i:@out_stream.

% [output OutStream Data] writes Data to OutStream
external pred output i:@out_stream, i:string.

% [flush OutStream] flush all output not yet finalized to OutStream
external pred flush i:@out_stream.

% [input InStream Bytes Data] reads Bytes from InStream
external pred input i:@in_stream, i:int, o:string.

% [input_line InStream Line] reads a full line from InStream
external pred input_line i:@in_stream, o:string.

% [eof InStream] checks if no more data can be read from InStream
external pred eof i:@in_stream.

%  -- System --

% [gettimeofday T] sets T to the number of seconds elapsed since 1/1/1970
external pred gettimeofday o:float.

% [getenv VarName Out] unifies Out with the value of VarName in the process'
% environment. Fails if no such environment variable exists
external pred getenv i:string, o:string.

% [system Command RetVal] executes Command and sets RetVal to the exit code
external pred system i:string, o:int.

%  -- Debugging --

% [term_to_string T S] prints T to S
external pred term_to_string i:any, o:string.

% == Elpi builtins =====================================

% [dprint ...] prints raw terms (debugging)
external type dprint variadic any prop.

% [print ...] prints terms
external type print variadic any prop.

% [counter Name Value] reads the Value of a trace point Name
external pred counter i:string, o:int.

% [rex_match Rex Subject] checks if Subject matches Rex. Matching is based
% on OCaml's Str library
external pred rex_match i:string, i:string.

% [rex_replace Rex Replacement Subject Out] Out is obtained by replacing all
% occurrences of Rex with Replacement in Subject. See also OCaml's
% Str.global_replace
external pred rex_replace i:string, i:string, i:string, o:string.

% [quote_syntax FileName QueryText QuotedProgram QuotedQuery] quotes the
% program from FileName and the QueryText. See elpi_quoted_syntax.elpi for
% the syntax tree
external pred quote_syntax i:string, i:string, o:list A, o:A.

% == Elpi nonlogical builtins =====================================

kind ctype type.

type ctype string -> ctype.

macro @safe :- ctype "safe".

% [var any term] checks if the term is a variable
external pred var i:any.

% [same_var first term second term] checks if the two terms are the same
% variable
external pred same_var i:A, i:A.

% [name T] checks if T is a eigenvariable
external pred name i:any.

external pred names % generates the list of eigenvariable
  o:list any. % list of eigenvariables in order of age (young first)
  
external pred occurs % checks if the constant occurs in the term
  i:A, % a constant (global or eigenvariable)
  i:A. % a term
  
% [closed_term T] unify T with a variable that has no eigenvariables in
% scope
external pred closed_term o:any.

% [is_cdata T Ctype] checks if T is primitive of type Ctype, eg (ctype
% "int")
external pred is_cdata i:any, o:ctype.

primitive? X S :- is_cdata X (ctype S).

% [new_int N] unifies N with a different int every time it is called
external pred new_int o:int.

% [new_safe Safe] creates a safe: a store that persists across backtracking
external pred new_safe o:@safe.

% [stash_in_safe Safe Data] stores Data in the Safe
external pred stash_in_safe i:@safe, i:any.

% [open_safe Safe Data] retrieves the Data stored in Safe
external pred open_safe i:@safe, o:list any.




