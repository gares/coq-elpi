

mk-compare-leaf [] [_|_] _ :- fatal-error "Non on the diagonal".
mk-compare-leaf [_|_] [] _ :- fatal-error "Non on the diagonal".
mk-compare-leaf [] [] Res :- coq-locate "true" Res.
mk-compare-leaf [ [X , TX] ] [ [Y , TY] ] Res :- !,
  assert (TX = TY) "oops4",
  eq-test TX F,
  Res = app [ F, X, Y ].
mk-compare-leaf [ [X , TX] | XS ] [ [Y , TY] | YS ] Res :-
  assert (TX = TY) "oops4",
  eq-test TX F,
  mk-compare-leaf XS YS ResXSYS,
  Res = app[ {{andb}}, ResXSYS, app [F, X, Y] ].

mk-eq-test3 Ity Args1 Kn Args Km (prod N T F) (lam N T CMP) :- !,
  pi x\ mk-eq-test3 Ity Args1 Kn [ [x,T] |Args] Km (F x) (CMP x).
mk-eq-test3 Ity Args1 Kn Args Km _ CMP :-
  assert (Ity = Else) "oops3",
  if (Kn = Km)
    (mk-compare-leaf Args1 Args CMP)
    (CMP = {{false}}).

mk-eq-test2 Ity Ktypes B Args Kn (prod N T F) (lam N T CMP) :- !,
  pi x\ mk-eq-test2 Ity Ktypes B [ [x,T] |Args] Kn (F x) (CMP x).
mk-eq-test2 Ity Ktypes B Args Kn _ CMP :-
  assert (Ity = Else) "oops2",
  CMP = (match B (lam _ Ity x\ {{bool}}) Bs),
  map-i Ktypes (mk-eq-test3 Ity Args Kn []) Bs.

mk-eq-test1 Ity Ktypes A B CMP :-
  CMP = (match A (lam _ Ity x\ {{bool}}) Bs),
  map-i Ktypes (mk-eq-test2 Ity Ktypes B []) Bs.


derive-eq N (prod _ S F) Ity Ktypes CMP CMPTY :- N > 0, !,
   M is N - 1,
   CMPTY = {{ forall (t : lp:S) (f : t -> t -> bool), lp:CMPTY2 t }},
   (pi t f\
     eq-test t f =>
     (derive-eq M (F t) {mk-app Ity [t]} {map Ktypes (subst-prod [t])}
       (CMP2 t f) (CMPTY2 t))),
   CMP = {{ fun (t : lp:S) (f : t -> t -> bool) => lp:CMP2 t f }}.
derive-eq _ (prod _ _ _) _ _ _ _ :- fatal-error "No idexes for now".
derive-eq 0 (sort _) Ity Ktypes CMP CMPTY :-
  CMPTY = {{ lp:Ity -> lp:Ity -> bool }},
  CMP = (fix "f" 0 CMPTY cmp\
           lam "x" Ity x\
           lam "y" Ity y\ F cmp x y),
  pi f x y\
    eq-test Ity f =>
    mk-eq-test1 Ity Ktypes x y (F f x y).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

derive-ind-branch (prod N S F) P K Ity A AT R RTY :- S = Ity,!,
  R = (lam N S x\ R2 x),
  RTY = (prod N S x\ prod "_" (app [ P , x]) h \ RTY2 x),
  ind-h H Rec,
  pi x\
    derive-ind-branch (F x) P K Ity [ app [Rec , x] , x |A] [x | AT] (R2 x) (RTY2 x).
derive-ind-branch (prod N S F) P K Ity A AT R RTY :-
  R = (lam N S x\ R2 x),
  RTY = (prod N S x\ RTY2 x),
  pi x\
    derive-ind-branch (F x) P K Ity [ x |A] [x|AT] (R2 x) (RTY2 x).
derive-ind-branch T P K Ity A AT R RTY :- (T = indt _ ; T = app [ indt _ | _ ]),
  RTY = {mk-app P [{mk-app K {rev AT}}]},
  ind-h H Rec,
  R = {mk-app H {rev A}}.

derive-ind1 [] [] Bs P Ity IND INDTY :-
  (pi f\ map {rev Bs} (x\y\y = x f) (Bs1 f)),
  INDTY = {{ forall x : lp:Ity, lp:"app [ P, {{x}} ]" }},
  IND = (fix "ind" 0 INDTY f\
           lam "x" Ity x\ 
             match x {{ fun x : lp:Ity => lp:"app [ P, {{x}} ]" }} (Bs1 f)).
derive-ind1 [T|TS] [K|Ks] Bs P Ity IND INDTY :-
  INDTY = {{ forall h : lp:BTY , lp:INDTY2 h }},
  IND = {{ fun h : lp:BTY => lp:IND2 h }},
  (pi f h\ ind-h h f => derive-ind-branch T P K Ity [] [] (B h f) BTY),
  pi h\
    derive-ind1 TS Ks [B h|Bs] P Ity (IND2 h) (INDTY2 h).
  
derive-ind N (prod _ S F) Ity Ktypes Knames IND INDTY :- N > 0, !,
   M is N - 1,
   INDTY = {{ forall t : lp:S, lp:INDTY2 t }},
   IND = {{ fun t : lp:S => lp:IND2 t }},
   pi t\
    derive-ind M (F t) 
     {mk-app Ity [t]} {map Ktypes (subst-prod [t])} {map Knames (x\r\mk-app x [t] r)}
      (IND2 t) (INDTY2 t).
derive-ind 0 (sort _) Ity Ktypes Knames IND INDTY :-
  INDTY = {{ forall P : lp:Ity -> Prop, lp:INDTY2 P }},
  IND = {{ fun P : lp:Ity -> Prop => lp:IND2 P }},
  pi p\
    derive-ind1 Ktypes Knames [] p Ity (IND2 p) (INDTY2 p).


% main entry point(s) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
coq-derive-eq-test (indt GR) :-
  coq-env-indt GR Ind ParamsNo UParamsNo Ty _Knames Ktypes,
  assert (Ind = tt) "No support for CoInductive data types",
  assert (ParamsNo = UParamsNo) "No support for non-uniform parameters",
  derive-eq ParamsNo Ty (indt GR) Ktypes CMP CMPTY,
  coq-string-of-gr GR S,
  EqName is S ^ "_equal",
  % coq-say CMP,
  % coq-say CMPTY,
  coq-env-add-const EqName CMP CMPTY _C.

coq-derive-induction (indt GR) :-
  coq-env-indt GR Ind ParamsNo UParamsNo Ty Knames Ktypes,
  assert (Ind = tt) "No support for CoInductive data types",
  assert (ParamsNo = UParamsNo) "No support for non-uniform parameters",
  derive-ind ParamsNo Ty (indt GR) Ktypes Knames IND INDTY,
  coq-string-of-gr GR S,
  EqName is S ^ "_induction",
  coq-say IND,
  coq-env-add-const EqName IND INDTY _C.
  

% vim:set ft=lprolog spelllang=:
