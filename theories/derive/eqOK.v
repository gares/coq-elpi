(* Generates correctness proofs for comparison functions generated by derive.eq.

   license: GNU Lesser General Public License Version 2.1 or later           
   ------------------------------------------------------------------------- *)

From elpi Require Import elpi
  derive.eq derive.projK derive.isK 
  derive.param1 derive.param1P derive.map
  derive.induction derive.isK derive.projK
  derive.cast.

From Coq Require Import ssreflect ssrbool.
(*
From Coq Require Import Bool List ssreflect.
From Coq Require Vector.

Elpi derive.param1 prod.
Elpi derive.param1 list.
Elpi derive.param1 nat.
Elpi derive.param1P prodR.
Elpi derive.param1P listR.
Elpi derive.param1P natR.
Elpi derive.map prodR.
Elpi derive.map listR.

Inductive nat1 := 
 | O1 
 | S1 (_ : nat1 * (bool * list nat1)).

Elpi derive.induction nat.
Elpi derive.induction bool.
Elpi derive.induction list.
Elpi derive.induction prod.
Elpi derive.induction nat1.

Elpi derive.eq list. 
Elpi derive.eq prod.
Elpi derive.eq bool.
Elpi derive.eq nat.
Elpi derive.eq nat1.

Elpi derive.isK bool.
Elpi derive.isK nat.
Elpi derive.isK list.
Elpi derive.isK prod.
Elpi derive.isK nat1.

Module Vector.
Elpi derive.eq Vector.t eq.
Elpi derive.induction Vector.t induction.
Elpi derive.isK Vector.t.
Elpi derive.projK Vector.t.
Elpi derive.param1 Vector.t R.
End Vector.

Print Vector.eq.

*)
Definition axiom T eqb x :=
  forall (y : T), reflect (x = y) (eqb x y).

Lemma reflect_eqf_base A B (f : A -> B) b x y : 
  reflect (x = y) b ->
  (forall x y, f x = f y -> x = y) ->
     reflect (f x = f y) b.
Proof.
case=> e; first by case: _ / e; constructor.
by move=> inj; constructor=> /inj.
Qed.

Lemma reflect_eqf_step2 A B C (f : forall a : A, B a -> C) b1 b2 x y z (w : B y) : 
   forall e : reflect (x = y) b1,
     (match e with
      | ReflectT _ e =>
            reflect (f x z = f x (cast2 A B _ _ e w)) b2
      | ReflectF _ abs =>
            forall x y z w, f x z = f y w -> x = y
     end) ->
      reflect (f x z = f y w) (b1 && b2).
Proof.
case=> e; first by case: _ / e w.
by move=> inj; constructor=> /inj.
Qed.

(* Elpi derive.eq sigT. 

Definition sigT_eq A fA P fP (s1 s2 : { a : A & P a }) : bool :=
  match s1, s2 with
  | existT _ a pa, existT _ b pb =>
      fA a b && fP a pa b pb
  end.
About sigT_eq.
  Print Vector.eq.

Fixpoint veq A fA n m (v1 : Vector.t A n) (v2 : Vector.t A m) {struct v1} :=
  match v1 with
  | Vector.nil _ =>
      match v2 with
      | Vector.nil _ => true
      | _ => false
      end
  | Vector.cons _ x m xs =>
      match v2 with
      | Vector.nil _ => false
      | Vector.cons _ y n ys => fA x y && nat_eq m n && veq A fA m n xs ys
      end
  end.

Search eq projT1.


Fixpoint v2l A n (v : Vector.t A n) : list A :=
  match v with
  | Vector.nil _ => nil
  | Vector.cons _ x m xs => cons x (v2l A m xs)
  end.

Fixpoint l2v A (l : list A) : { n : nat & Vector.t A n } :=
  match l with
  | nil => existT _ 0 (Vector.nil _)
  | cons x xs =>
      let: existT _ j v := l2v _ xs in
      existT _ (S j) (Vector.cons _ x j v)
  end.

Lemma vl A n v : l2v A (v2l A n v) = existT _ n v.
Proof. by elim: v => //= x j xs ->. Qed.

Lemma lv A l : let v := l2v A l in v2l A _ (projT2 v) = l.
Proof.
elim: l => //= x xs.
by case: (l2v A xs) => j v IH /=; congr (_ :: _).
Qed.

Lemma list_eqOK A f :
  forall x (HA : listR A (axiom A f) x),
  axiom (list A) (list_eq A f) x.
Admitted.

Definition bij A B f := { g : B -> A & forall x, g (f x) = x }.

Lemma bij_l2v A : bij _ _ (l2v A).
Proof.
move.
exists (fun v => v2l A (projT1 v) (projT2 v)).
exact: lv.
Qed.

Definition inj A B (f : A -> B) := forall x y : A, f x = f y -> x = y.

Lemma inj_v2l A n : inj _ _ (v2l A n).
Proof.
elim => [y|].
  by refine match y with Vector.nil _ => _ end.
move=> x j xs IH y.
move: xs IH; rewrite -[j]/(pred (S j)). 
  refine match y with Vector.cons _ y k ys => _ end.
by move=> /= xs IH [-> /IH->].
Qed.

Lemma axiomK A B cmp f (inj_f : inj B A f) b1 :
  axiom A cmp (f b1) -> axiom B (fun x y => cmp (f x) (f y)) b1.
Proof.
move=> H b2.
have [/inj_f -> |nE ] := H (f b2).
  by constructor 1.
by constructor 2 => Hb; apply: nE; rewrite Hb.
Qed.

Definition veq A f n v1 v2 := list_eq A f (v2l A n v1) (v2l A n v2).

Lemma vR2lR A PA n pn v : Vector.tR A PA n pn v -> listR A PA (v2l A n v).
Proof.
elim => /= [| hd Phd j Pj tl Ptl IH].
  by constructor 1.
by constructor 2.
Qed.

Lemma veq_OK A f :
  forall x px v (HA : Vector.tR A (axiom A f) x px v),
  axiom (Vector.t A x) (veq A f x) v.
Proof.
move=> x px v H.
apply: axiomK.
  by apply: inj_v2l.
apply: list_eqOK.
by apply: vR2lR H.
Qed.
 

(* fgffff *)

have xH := axiomK _ _ _ _ (bij_l2v A). (list_eqOK A f _ _).
 apply: list_eqOK.

Definition veqSig A fA (v1 : { n : nat & Vector.t A n}) (v2 : { m : nat & Vector.t A m }) : bool :=
  match v1, v2 with
  | existT _ a pa, existT _ b pb =>
      nat_eq a b && veq A fA a b pa pb
  end.

Axiom nat_eqOK : forall x, axiom nat nat_eq x.

Lemma veqSigOK A fA x v :
  axiom (Vector.t A x) (veq A fA x x) v -> axiom ({ n : nat & Vector.t A n}) (veqSig A fA) (existT _ x v).
Proof.
move=> Hxx [y w]; rewrite /veqSig.
case: (nat_eqOK x y) w => [<- w|??]; last by constructor 2 => /projT1_eq.
case: Hxx => [->| Evw]; first by constructor 1.
constructor 2 => Esig; have H := Eqdep_dec.inj_pair2_eq_dec _ _ _ _ _ _ Esig.
by apply/Evw/H=> i j; case: (nat_eqOK i j); [ left | right ].
Qed.

Lemma veqSigOK1 A fA x v :
  axiom ({ n : nat & Vector.t A n}) (veqSig A fA) (existT _ x v) ->
  axiom (Vector.t A x) (veq A fA x x) v.
Proof.
move: x v.
apply: Vector.induction.
  move=> XX v2; have [] := XX (existT _ 0 v2).
  admit. admit.
move=> b j bs IH XX v2; have [] := XX (existT _ _ v2).

move=> Hsig v2.
case: (Hsig (existT _ x v2)).

move=> Hxx [y w]; rewrite /veqSig.
case: (nat_eqOK x y) w => [<- w|??]; last by constructor 2 => /projT1_eq.
case: Hxx => [->| Evw]; first by constructor 1.
constructor 2 => Esig; have H := Eqdep_dec.inj_pair2_eq_dec _ _ _ _ _ _ Esig.
by apply/Evw/H=> i j; case: (nat_eqOK i j); [ left | right ].
Qed.

Lemma veqOK A f : 
  forall x px v (HA : Vector.tR A (axiom A f) x px v),
  axiom (Vector.t A x) (veq A f x x) v.
Proof.
move=> x px v1 Hf v2; move: x v1 v2 px Hf.
apply: Vector.induction.
  move=> [|b j bs] _ _.
  by constructor 1.
  by constructor 2; apply: equal_idx.
move=> x m xs IH n [_ _|y j ys R Hf /=].
  by constructor 2; apply: equal_idx.
inversion Hf.
case: (X y); last first.
  move=> E; constructor 2. admit.
have nat_eqOK : forall x, axiom nat nat nat_eq x.
  admit.
case: (nat_eqOK m j); last first.
  move=> E; constructor 2. admit.
move=> ? ?.
Admitted.

End Test.

Check veqOK.


Search eq existT .
have := reflect_eqf_base (IH j ys Pn X0).


  case: {-3}_ _ {-}_ / Hf (eq_refl (Vector.cons A x m xs)) (eq_refl (S m)) => //.

    by constructor 2; apply: equal_idx.

refine match v2 with Vector.nil _ => _ | Vector.cons _ y n ys => _ end.
  by [].



 case. => [ [|//]| ]. x m xs IH mR pf ].



Lemma list_eqOK A f :
  forall x (HA : listR A (axiom A f) x),
  axiom (list A) (list_eq A f) x.
Proof.
move=> l; elim => [|x Px xs Pxs IH] [|y ys].
- constructor 1; reflexivity.
- constructor 2 => ?; discriminate.
- constructor 2 => ?; discriminate.
- apply: reflect_eqf_step2 (Px y) _.
  case: (Px y) => [p|np].
    case: _ / p; apply: reflect_eqf_base; first by apply: IH.
    by move=> ?? [->].
  by move=> ???? [->].
Qed.


(*
Lemma reflect_eqf_step3 A B C D
 (f : forall a : A, forall b : B a, C a b -> D) b1 b2 
x y z (w : B y) r (s : C y w) : 
   forall e : reflect (x = y) b1,
     (match e with
      | ReflectT _ e =>
            reflect (f x z r = 
                     f x (cast2 A B _ _ e w) (cast3 A B C _ _ e _ s)) b2
      | ReflectF _ abs =>
             forall x y z w r s, f x z r = f y w s -> x = y
     end) ->
      reflect (f x z r = f y w s) (b1 && b2).
Proof.
case=> e; first by case: _ / e w s.
by move=> inj; constructor=> /inj.
Qed.
*)
*)
Axiom daemon : False.


Elpi Command derive.eqOK.
Elpi Accumulate Db derive.isK.db.
Elpi Accumulate File "ltac/discriminate.elpi".
Elpi Accumulate Db derive.param1.db.
Elpi Accumulate Db derive.param1P.db.
Elpi Accumulate Db derive.induction.db.
Elpi Accumulate Db derive.cast.db.
Elpi Accumulate File "derive/eqOK.elpi".
Elpi Accumulate "
  main [str I, str F] :- !,
    coq.locate I (indt GR),
    coq.locate F (const Cmp),
    derive.eqOK.main GR Cmp.
  main _ :- usage.

  usage :- coq.error ""Usage: derive.eqOK <inductive type name> <comparison function>"".
".
Elpi Typecheck.
 

Elpi derive.param1 prod.
Elpi derive.param1 list.
Elpi derive.param1 nat.
Elpi derive.param1P prodR.
Elpi derive.param1P listR.
Elpi derive.param1P natR.
Elpi derive.map prodR.
Elpi derive.map listR.

Elpi derive.induction nat.
Elpi derive.induction bool.
Elpi derive.induction list.
Elpi derive.induction prod.

Elpi derive.eq list. 
Elpi derive.eq prod.
Elpi derive.eq bool.
Elpi derive.eq nat.

Elpi derive.isK bool.
Elpi derive.isK nat.
Elpi derive.isK list.
Elpi derive.isK prod.

Elpi derive.eqOK bool bool_eq.
Check bool_eqOK : forall x, axiom bool bool_eq x.

Elpi derive.eqOK nat nat_eq.
Check nat_eqOK : forall x, axiom nat nat_eq x.

(*

Elpi derive.eqOK list list_eq.
Print list_eqOK.




Lemma nat_eqOK x : axiom nat nat_eq x.
Proof.
move: x; apply: nat_induction => [|x]. case.
  by constructor.
  by move=> x; constructor.
move=> IH; case.
  by constructor.
move=> y.
apply: reflect_eqf_base.
  by move=> a b H; injection H.
apply: IH.
Qed.


Inductive foo :=
  K (b : bool) (q : bool) (n : nat).
Elpi derive.eq foo.
Elpi derive.induction foo.

Lemma foo_eqOK x : axiom foo foo_eq x.
move: x; apply: foo_induction=> b q n; case=> b1 q1 n1.
unshelve apply: reflect_eqf_step3.
  by apply: bool_eqOK.
case: bool_eqOK=> [e|].
  case: _ / e.
  unshelve apply: reflect_eqf_step2.
  by apply: bool_eqOK.
case: bool_eqOK=> [e|].
  case: _ / e.
  unshelve apply: reflect_eqf_base.
    admit.
  apply: nat_eqOK.
admit.
admit.



Lemma bool_eqOK x : axiom bool bool_eq x.
Proof.
elim: x => -[|]; by constructor.
Qed.

Lemma list_eqOK A f :
  forall x (HA : list_param1 A (axiom A f) x),
  axiom (list A) (list_eq A f) x.
Proof.
move=> l; elim => [|x Px xs Pxs IH] [|y ys].
- constructor 1; reflexivity.
- constructor 2 => ?; discriminate.
- constructor 2 => ?; discriminate.
- apply: reflect_eq_f2=> [????[]|????[]||] //.
Qed.

Lemma prod_eqOK A f B g :
  forall x (H : prod_param1 A (axiom A f) B (axiom B g) x),
  axiom (A * B) (prod_eq A f B g) x.
Proof.
move=> x [a Ha b Hb] [w z].
apply: reflect_eq_f2 => [????[]|????[]||] //. 
Qed.

Lemma nat1_eqOK x : axiom nat1 nat1_eq x.
Proof.
apply: (nat1_induction (axiom nat1 nat1_eq)) => [ | a IH] [ | b ].
- constructor 1 => //.
- constructor 2 => ?; discriminate.
- constructor 2 => ?; discriminate.
- apply: reflect_eq_f1.
  + by move=> ?? [E].
  + rewrite /=.
    apply: prod_eqOK.
    apply: prodR_map IH => // l Hl.
    apply: list_eqOK.  
    apply: listR_map Hl => //.
Qed.

*)
